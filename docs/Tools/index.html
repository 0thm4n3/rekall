
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Rekall Memory Forensic Framework</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Rekall Memory Forensic Framework">

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/rekall.css" rel="stylesheet">
    <link href="/css/asciidoc.css" rel="stylesheet">
    <link href="/css/font-awesome.css" rel="stylesheet">
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//code.jquery.com/ui/1.10.4/jquery-ui.js"></script>
    <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="//code.jquery.com/ui/1.10.4/themes/smoothness/jquery-ui.css">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></sc\
ript>
    <![endif]-->
  </head>

  <body>


  <div class="background">
   <header class="header">
    <div class="navbar navbar-fixed-top navbar-inverse">
     <div class="navbar-inner">
      <div class="container">
       <a class="navbar-brand" href="/"
          style="padding-top: 0px; padding-bottom: 0px;"
          >
          <img src="/img/Rekall-small.png" class="small_logo"></img>
       </a>
       <ul class="nav navbar-nav navbar-collapse collapse">

        <li class="divider-vertical"></li>
        
    <li class="">
     <a href="/index.html">
      Home
     </a>
    </li>
    
        <li class="divider-vertical"></li>
        
    <li class="">
     <a href="/about.html">
      About
     </a>
    </li>
    
        <li class="divider-vertical"></li>
        
    <li class=" dropdown">
     <a class="dropdown-toggle"
      id="dropdownMenuReleases"
      data-toggle="dropdown"
      aria-expanded="true">
    Releases
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenuReleases">

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Releases/releases-1.2.1.html">Version 1.2.1 Col de la Croix.</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Releases/releases-1.3.1.html">Version 1.3.2 Dammastock.</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Releases/releases-1.4.0.html">Version 1.4.0 Etzel.</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Releases/releases-1.5.2.html">Version 1.5.2 Furka..</a></li>

  </ul>
 </li>

        <li class="divider-vertical"></li>
        
    <li class=" dropdown">
     <a class="dropdown-toggle"
      id="dropdownMenuDocumentation"
      data-toggle="dropdown"
      aria-expanded="true">
    Documentation
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenuDocumentation">

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/docs/Manual">Rekall User Manual</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/docs/Developers">Developer Documentation.</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/docs/GUI">Rekall GUI</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/docs/MemoryAnalysis.html">Memory Analysis Course</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/docs/References">References</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/docs/Tools">The Pmem Memory acquisition suite.</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/docs/index.html"></a></li>

  </ul>
 </li>

        <li class="divider-vertical"></li>
        
    <li class=" dropdown">
     <a class="dropdown-toggle"
      id="dropdownMenuDiscuss"
      data-toggle="dropdown"
      aria-expanded="true">
    Discuss
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenuDiscuss">

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Discuss/blog.html">The Rekall Blog</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Discuss/github.html">GitHub</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Discuss/index.html"></a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Discuss/issue.html">Issue Tracker</a></li>

    <li role="presentation"><a role="menuitem" tabindex="-1" href="/Discuss/mailinglist.html">Mailing List</a></li>

  </ul>
 </li>

        <li class="divider-vertical"></li>
        
    <li class="">
     <a href="/faq.html">
      FAQ
     </a>
    </li>
    
       <li>
        <a href="https://github.com/google/rekall/edit/gh-pages/docs/Tools/index.md?message=Describe%20your%20change..."
           data-toggle="tooltip"
           data-placement="bottom"
           title="Improve this page"
           class="improve-docs activate_tooltip">
         <i class="glyphicon glyphicon-edit"></i>
        </a>
       </ul>

       <form class="navbar-search col-md-3 docs-search" role="search"
             action="/search.html">
       <span class="glyphicon glyphicon-search search-icon"></span>
       <input type="text" name="q" data-i-search-input="true"
         class="search-query"
         placeholder="Site Search">
       </form>
      </div>
     </div>
    </div>
   </header>

<div class="container-fluid page-background container">
<div class="main">
  <div class="col-md-2">
    
<ul class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix rekall-side-nav">
 <a href="/docs/index.html" class="btn btn-default btn-lg btn-block">
  <span class="glyphicon glyphicon-arrow-left"></span> docs
 </a>

 <a href='/docs/Tools/index.html' class="btn btn-default btn-lg btn-block">
   Tools
 </a>
 <p>

<ul class='nav nav-pills nav-stacked'>
    <li class=''>
      <a href='/docs/Tools/pmem.html' class="category-link">
        The Pmem Memory acquisition suite (Legacy).
      </a>
    </li>
    </ul></ul>
  </div>

  <div class="col-md-10">
    


<h1 id="#The Pmem Memory acquisition suite." class="anchor" >The Pmem Memory acquisition suite.</h1>


<div class="abstract">
<h2></h2>
</div>



<p>The Rekall project has maintained a set of open source memory acquisition tools
for a while now. After all, Memory acquisition is the first step in memory
analysis. Before any analysis can be done, we need to acquire the memory in the
first place. There are a number of commercial solutions to acquire memory, but
sadly open source solutions have been abandoned or not maintained (For example
win32dd has been a popular solution many years ago but has now been
commercialized and is no longer open source).</p>
<p>We believe in open source forensic tools to make testing and transparency
easier. We also believe that the availability of open source solutions spurs
further development in the field and enables choices.</p>
<p>That is the reason we feel an open source, well tested and capable forensic
memory acquisition tool is essential - we call it the Pmem suite of tools. The
pmem acquisition tool aims to provide a complete imaging solution for Windows,
Linux and OSX (OSXPmem is the only memory acquisition tool we are aware of,
which works on the latest version of OSX - 10.10.x - commercial or open source).</p>
<p>As we continue to develop Rekall into the most powerful memory forensic
platform, we developed the need to extend the acquisition tool. For example,
when Rekall gained the ability to analyze the windows pagefile, it became
important that the acquisition tool also collect the page file during
acquisition. Similarly we require the tool to collect critical system binaries.</p>
<p>We realized that we were in a unique position - not only are we developing the
most cutting edge memory analysis tool, but we are also developing the most
advanced memory acquisition tool. By being in control of the development process
of both tools, we can leverage the acquisition to assist the analysis, and
leverage the analysis to improve the acquisition.</p>
<p>For example, one of the first things that a memory analysis framework requires
is to derive the location of the page tables (dtb or CR3), the location of the
kernel image in memory (kaslr shift) or the exact version of the kernel. All of
these facts are immediately available to the acquisition tool at acquisition
time - if only there was a way for the acquisition tool to store this metadata
in the image, we would be able to analyze the image faster and more accurately.</p>
<p>Similarly, we often analyze memory images we acquired and discover that we left
some evidence behind during acquisition time - for example, if we try to dump
executables from memory, we might discover that many file mapped pages are not
present in the image. If only we could have acquired these files during the
acquisition time&hellip;</p>
<p>Our goal is to create a synergy between analysis and acquisition - collect as
much information as we can during the acquisition stage, driven by preliminary
analysis.</p>
<p>In order to do this preliminary triaging, we need to gain access to the live
physical memory of the system. Pmem is the only suite of memory acquisition
tools that allow for live forensics of the system they are running on. While
other acquisition tools are designed to dump memory image files from kernel
space, pmem tools generally pass data into user space and allow user space
processes direct access to physical memory.</p>
<p>It turns out that as physical memory sizes increase it takes so long to copy a
complete image out to disk, that smear is becoming a significant problem
(e.g. on very large servers). In this case live forensic analysis is the only
practical solution since the physical memory is examined over a very short
period of time (think running a pslist plugin which just follows a linked list).</p>
<p>We actually believe live memory analysis is the way forward.</p>
<h2>Image file format</h2>
<p>Traditionally acquisition tools (like dd) simply wrote out a RAW format
image. This is by far the simplest image file format. In this format, the
physical address space is written byte for byte directly into the image file.</p>
<p>The nice thing about a raw image is that you don&rsquo;t need any special tools to read
it - every byte in the file corresponds to the same address in physical
memory. Some of the earliest memory analysis tools therefore only worked on RAW
images.</p>
<p>However there are a number of problems with RAW images:</p>
<ul>
<li>
<p>No ability to store sparse regions - all reserved regions must be padded in
  the image with zeros giving a larger image size. For example if you have 4GB
  of RAM, there will be about 1GB PCI hole reserved for DMA (e.g. video cards),
  so the RAW image is actually 5GB in size.</p>
</li>
<li>
<p>No support for compression, encryption etc. This is a problem because
  sometimes using a fast compressor can actually produce higher throughput by
  minimizing IO.</p>
</li>
<li>
<p>No support for additional metadata. This is required for the acquisition tool
  to tell us these critical constants we need for analysis!</p>
</li>
<li>
<p>No support for embedding additional files, such as the pagefile, kernel image
  etc.</p>
</li>
</ul>
<p>There are some other image file formats sometimes used but none of them have all
the required features:</p>
<p>The Microsoft Crashdump file, for example, is commonly used with windows images
- however this is a proprietary, undocumented file format with no support for
compression or embedding (although it supports some windows specific metadata)
it is also non-extensible. We do not recommend acquiring with this format
directly - if you need to analyze the image with the windows debugger we
recommend using the Rekall <code>raw2dmp</code> plugin to create a dump file later.</p>
<p>An ELF core file is the standard image format used by GDB and Linux when making
a core dump. This format allows the storage of sparse memory regions, but has
only limited support for extensible metadata. It is not possible to use this
format to collect related files (like the pagefile, kernel image etc). This
format is the default produced by versions of Rekall&rsquo;s pmem acquisition tools
prior to version 2.0. Certain virtualization tools like Virtual Box produce
memory images in this format so it can still be useful.</p>
<p>EWF is a compression format which is used by Encase. It offers the ability for
the image to be compressed but does not support sparse files, nor multiple
streams (at least the versions supported by the open source libewf tool).</p>
<p>Various ad-hoc imaging formats that are sometimes used. Rekall can read those if
you receive them in this format, but these format are not suitable for our
purposes (no compression or multiple files can be collected in the same image
file):</p>
<ul>
<li>Limes - an ad-hoc imaging format sometimes used on Linux. Does not really
  offer any advantages over an ELF core dump.</li>
<li>HPAK - A proprietary format used in HBGary&rsquo;s tools.</li>
<li>Mach-O - This is the binary format used on OSX. These kind of images used to
  be produced by the now defunct &ldquo;Mac Memory Reader&rdquo;. Does not really offer any
  advantages over ELF core dumps.</li>
</ul>
<p>After version 2.0 Rekall&rsquo;s pmem suite of acquisition tools have switched to the
AFF4 format for the default image format. AFF4 offers all the required features
and more:</p>
<ul>
<li>
<p>A peer reviewed open standard for storing digital images.</p>
</li>
<li>
<p>Supports compression using the <code>Zlib</code> and <code>Snappy</code> compression formats (Snappy
  allows imaging at speeds greater than 300mb/s). This is really important to
  reduce memory smear.</p>
</li>
<li>
<p>Supports storing arbitrary metadata via RDF information triples.</p>
</li>
<li>
<p>Supports collecting multiple files (streams) in the same file. Thus we can
  collect binaries, pagefile as well as the physical memory the time of
  acquisition. Rekall can then use all these information sources seamlessly
  during analysis (i.e. no need to explicitly tell Rekall which is the
  pagefile).</p>
</li>
</ul>
<p>The image file format is based on the standard Zip file format, with all the
advantages that brings, such as readily available tools for recovery of
corrupted image files, inspection, verification and manipulation of zip files.
Zip files are natively supported in almost every programming language -
decompressing an AFF4 stream can be done in 4 lines of python without the use of
a special AFF4 library (but the <code>pyaff4</code> library can also be used).</p>
<h2>AFF4 Volume overview.</h2>
<p>We said that the AFF4 format is built on top of the standard ZIP format. This
means we can actually use the regular zip program to inspect an AFF4 volume.</p>
<p>The following is an image of a Windows Server 2003 system, acquired together
with the pagefile. As you can see it is just a zip file:</p>
<div class="highlight"><pre><span class="nv">$ </span>unzip -l images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4

Archive:  images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4
aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed
  Length      Date    Time    Name
---------  ---------- -----   ----
      <span class="m">847</span>  2015-03-10 00:50   information.turtle
       <span class="m">56</span>  2015-03-10 00:50   PhysicalMemory/map
       <span class="m">64</span>  2015-03-10 00:50   PhysicalMemory/idx
 <span class="m">12313883</span>  2015-03-10 00:50   PhysicalMemory/data/00000031
     <span class="m">4048</span>  2015-03-10 00:50   PhysicalMemory/data/00000031/index
        <span class="m">8</span>  2015-03-10 00:50   c%3a/pagefile.sys/00000016
     <span class="m">4096</span>  2015-03-10 00:49   PhysicalMemory/data/00000021/index
     <span class="m">4096</span>  2015-03-10 00:49   PhysicalMemory/data/00000024/index
...
   <span class="m">166912</span>  2015-03-10 00:50   c%3a/pagefile.sys/00000012
   <span class="m">166912</span>  2015-03-10 00:50   c%3a/pagefile.sys/00000013
     <span class="m">4096</span>  2015-03-10 00:50   c%3a/pagefile.sys/00000015/index
      <span class="m">204</span>  2015-03-10 00:50   PhysicalMemory/information.yaml
        <span class="m">4</span>  2015-03-10 00:50   c%3a/pagefile.sys/00000016/index
---------                     -------
<span class="m">278598663</span>                     <span class="m">102</span> files
</pre></div>


<p>We can see that the AFF4 volume is denoted by a globally unique name
<code>aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed</code>. This is called the AFF4 URN and
uniquely identifies this volume. The metadata is stored in this volume&rsquo;s archive
member called &ldquo;information.turtle&rdquo;. We also see a number of streams - The<code>PhysicalMemory</code> is the memory stream of the machine&rsquo;s physical memory,
&ldquo;c%3a/pagefile.sys&rdquo; is the stream corresponding with the machine&rsquo;s pagefile.</p>
<p>Lets examine the metadata stored in the information.turtle archive member:</p>
<div class="highlight"><pre>$ unzip -p images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4 information.turtle
@base <span class="nt">&lt;aff4:</span><span class="err">//4928ef44-6579-496c-a53e-2ad34d98b7ed</span><span class="nt">&gt;</span> .
@prefix rdf: <span class="nt">&lt;http:</span><span class="err">//www.w3.org/1999/02/22-rdf-syntax-ns#</span><span class="nt">&gt;</span> .
@prefix aff4: <span class="nt">&lt;http:</span><span class="err">//aff4.org/Schema#</span><span class="nt">&gt;</span> .
@prefix xsd: <span class="nt">&lt;http:</span><span class="err">//www.w3.org/2001/XMLSchema#</span><span class="nt">&gt;</span> .
@prefix memory: <span class="nt">&lt;http:</span><span class="err">//aff4.org/Schema#memory</span><span class="nt">/&gt;</span> .

<span class="nt">&lt;/PhysicalMemory&gt;</span>
    aff4:category memory:physical ;
    aff4:stored <span class="err">&lt;</span>&gt; ;
    a aff4:map .

<span class="err">&lt;</span>/PhysicalMemory/data&gt;
    aff4:chunk_size 32768 ;
    aff4:chunks_per_segment 1024 ;
    aff4:compression <span class="nt">&lt;https:</span><span class="err">//www.ietf.org/rfc/rfc1950.txt</span><span class="nt">&gt;</span> ;
    aff4:size 1073336320 ;
    aff4:stored <span class="err">&lt;</span>&gt; ;
    a aff4:image .

<span class="err">&lt;</span>/c:/pagefile.sys&gt;
    aff4:category memory:pagefile ;
    aff4:chunk_size 32768 ;
    aff4:chunks_per_segment 1024 ;
    aff4:compression <span class="nt">&lt;https:</span><span class="err">//www.ietf.org/rfc/rfc1950.txt</span><span class="nt">&gt;</span> ;
    memory:pagefile_number 0 ;
    aff4:size 536870912 ;
    aff4:stored <span class="err">&lt;</span>&gt; ;
    a aff4:image .
</pre></div>


<p>This shows us all the streams that exist in this volume encoded using the Turtle
RDF serialization. Each stream has a number of attributes (key value pairs). The
stream <code>aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed/PhysicalMemory</code> has a
category of memory:physical (i.e. it is a physical memory image). It is
implemented as an <code>aff4:map</code> stream - i.e. this is a sparse stream which uses
<code>aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed/PhysicalMemory/data</code> as backing
storage.</p>
<p>We can see the backing stream is an <code>aff4:image</code> typed stream with 32kb chunks,
1024 chunks per segment, using zlib compression.</p>
<p>Additionally we can see the pagefile is stored in a separate stream with a
category <code>memory:pagefile</code> (Rekall can then use the category to automatically
know how to use each stream).</p>
<h1>The PMEM suite of acquisition tools.</h1>
<p>The Rekall project maintains a set of acquisition tools for the three supported
operating systems: Windows, Linux and OSX. Since version 2.0, the three imagers
have been merged into a single common framework. This means that you use them in
the same way, and they all produce the same type of AFF4 images.</p>
<p>All imagers share the common AFF4 imager architecture. This means you can use
all imagers for basic manipulation of all AFF4 volumes. Hence we will discuss
these common features here. Below we discuss some of the differences in the
implementations between the operating systems.</p>
<p>Lets consider the output from the &ndash;help command:</p>
<div class="highlight"><pre>$ linpmem --help
USAGE:

   linpmem  [--elf] [-m] [-p <span class="err">&lt;</span>/path/to/pagefile&gt;] ...  [-V] [-d] [-v] [-t]
            [-i <span class="err">&lt;</span>/path/to/file/or/device&gt;] ...  [-e <span class="nt">&lt;string&gt;</span>] [-o
            <span class="err">&lt;</span>/path/to/file&gt;] [-c <span class="nt">&lt;zlib</span><span class="err">,</span> <span class="err">snappy,</span> <span class="err">none</span><span class="nt">&gt;</span>] [--] [--version]
            [-h] <span class="err">&lt;</span>/path/to/aff4/volume&gt; ...


Where:

   --elf
     Normally pmem will produce an AFF4 volume but this option will force
     an ELF Core image file to be produced during acquisition. Note that
     this option is not compatible with the --input or --pagefile options
     because we can not write multiple streams into an ELF file.

     This option is mostly useful for compatibility with legacy memory
     analysis tools which do not understand AFF4 images.

     If this option is used together with the --export option we will
     export an ELF file from a stream within the AFF4 image.

   -m,  --acquire-memory
     Normally pmem will only acquire memory if the user has not asked for
     something else (like acquiring files, exporting etc). This option
     forces memory to be acquired. It is only required when the program is
     invoked with the --input, --export or other actionable flags.


   -p <span class="err">&lt;</span>/path/to/pagefile&gt;,  --pagefile <span class="err">&lt;</span>/path/to/pagefile&gt;  (accepted
      multiple times)
     Also capture the pagefile. Note that you must provide this option
     rather than e.g. &#39;--input c:\pagefile.sys&#39; because we can not normally
     read the pagefile directly. This option will use the sleuthkit to read
     the pagefile.

   -V,  --view
     View AFF4 metadata

   -d,  --debug
     Display debugging logging

   -v,  --verbose
     Display more verbose information

   -t,  --truncate
     Truncate the output file. Normally volumes and images are appended to
     existing files, but this flag forces the output file to be truncated
     first.

   -i <span class="err">&lt;</span>/path/to/file/or/device&gt;,  --input <span class="err">&lt;</span>/path/to/file/or/device&gt;
      (accepted multiple times)
     File to image. If specified we copy this file to the output volume
     located at --output. If there is no AFF4 volume on --output yet, we
     create a new volume on it.

     This can be specified multiple times with shell expansion. e.g.:

     -i /bin/*

   -e <span class="nt">&lt;string&gt;</span>,  --export <span class="nt">&lt;string&gt;</span>
     Name of the stream to export. If specified we try to open this stream
     and write it to the --output file. Note that you will also need to
     specify an AFF4 volume path to load so we know where to find the
     stream. Specifying a relative URN implies a stream residing in a
     loaded volume. E.g.

     -e /dev/sda -o /tmp/myfile my_volume.aff4

   -o <span class="err">&lt;</span>/path/to/file&gt;,  --output <span class="err">&lt;</span>/path/to/file&gt;
     Output file to write to. If the file does not exist we create it.

   -c <span class="nt">&lt;zlib</span><span class="err">,</span> <span class="err">snappy,</span> <span class="err">none</span><span class="nt">&gt;</span>,  --compression <span class="nt">&lt;zlib</span><span class="err">,</span> <span class="err">snappy,</span> <span class="err">none</span><span class="nt">&gt;</span>
     Type of compression to use (default zlib).

   --,  --ignore_rest
     Ignores the rest of the labeled arguments following this flag.

   --version
     Displays version information and exits.

   -h,  --help
     Displays usage information and exits.

   <span class="err">&lt;</span>/path/to/aff4/volume&gt;  (accepted multiple times)
     These AFF4 Volumes will be loaded and their metadata will be parsed
     before the program runs.

     Note that this is necessary before you can extract streams with the
     --export flag.


   The LinuxPmem memory imager.  Copyright 2014 Google Inc.
</pre></div>


<h2>Inspecting an AFF4 Volume.</h2>
<p>The tool can examine an AFF4 volume as we have seen previously. It actually
loads the provided AFF4 volume and outputs a common view of all known objects.</p>
<div class="highlight"><pre><span class="nv">$ </span>linpmem -V images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix aff4: &lt;http://aff4.org/Schema#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix memory: &lt;http://aff4.org/Schema#memory/&gt; .

&lt;aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed/PhysicalMemory&gt;
    aff4:category memory:physical <span class="p">;</span>
    aff4:stored &lt;aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed&gt; <span class="p">;</span>
    a aff4:map .

&lt;aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed/PhysicalMemory/data&gt;
    aff4:chunk_size <span class="m">32768</span> <span class="p">;</span>
    aff4:chunks_per_segment <span class="m">1024</span> <span class="p">;</span>
    aff4:compression &lt;https://www.ietf.org/rfc/rfc1950.txt&gt; <span class="p">;</span>
    aff4:size <span class="m">1073336320</span> <span class="p">;</span>
    aff4:stored &lt;aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed&gt; <span class="p">;</span>
    a aff4:image .

&lt;aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed/c:/pagefile.sys&gt;
    aff4:category memory:pagefile <span class="p">;</span>
    aff4:chunk_size <span class="m">32768</span> <span class="p">;</span>
    aff4:chunks_per_segment <span class="m">1024</span> <span class="p">;</span>
    aff4:compression &lt;https://www.ietf.org/rfc/rfc1950.txt&gt; <span class="p">;</span>
    memory:pagefile_number <span class="m">0</span> <span class="p">;</span>
    aff4:size <span class="m">536870912</span> <span class="p">;</span>
    aff4:stored &lt;aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed&gt; <span class="p">;</span>
    a aff4:image .

&lt;file:///home/scudette/projects/workshop/02-What_is_memory/images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4&gt;
    aff4:contains &lt;aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed&gt; .
</pre></div>


<h2>Extracting a stream from an AFF4 volume.</h2>
<p>We can extract one of the streams to a file. This is sometimes useful for using
tools which do not support AFF4 natively. For example, we can extract the
pagefile into the /tmp/ directory:</p>
<div class="highlight"><pre><span class="nv">$ </span>linpmem --export /c:/pagefile.sys --output /tmp/pagefile.sys images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4

Extracting aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed/c:/pagefile.sys into file:///tmp/pagefile.sys
 Reading 0xa00000  10MiB / 512MiB 0MiB/s
 Reading 0x5000000  80MiB / 512MiB 266MiB/s
 Reading 0xc800000  200MiB / 512MiB 474MiB/s
 Reading 0x15e00000  350MiB / 512MiB 586MiB/s
 Reading 0x19a00000  410MiB / 512MiB 236MiB/s
 Reading 0x1d600000  470MiB / 512MiB 216MiB/s
</pre></div>


<h2>Adding a new stream to an AFF4 volume.</h2>
<p>By default the AFF4 imager tools append streams to existing volumes, rather than
overwrite the volume. Therefore it is easy to add additional files after the
acquisition is complete to the acquired volume. It is also possible to specify
shell globs to add multiple files to the volume. In this sense, the AFF4 volume
acts more like a zip container - you can just keep on adding new files.</p>
<p>This is handy if initial analysis reveals some suspected files which we can
acquire immediately into the AFF4 volume after the memory is captured. The -t
flag explicitly allows pmem to truncate the output file (this will delete all
current content of the volume).</p>
<p>For example, the following will add files in /bin/* to the AFF4 volume (without
overwriting it).</p>
<div class="highlight"><pre><span class="nv">$ </span>linpmem -i /bin/* -o /tmp/test.aff4

Adding /bin/bash as file:///bin/bash
Adding /bin/bsd-csh as file:///bin/bsd-csh
Adding /bin/bunzip2 as file:///bin/bunzip2
Adding /bin/busybox as file:///bin/busybox
Adding /bin/bzcat as file:///bin/bzcat
Adding /bin/bzcmp as file:///bin/bzcmp
Adding /bin/bzdiff as file:///bin/bzdiff
</pre></div>


<h1>The WinPmem acquisition tool.</h1>
<p>On Windows, one must insert a signed driver in order to gain access to physical
memory. WinPmem from version 2.0 is built on top of the AFF4 imager technology,
and is packaged bundled with the appropriate memory drivers. Since AFF4 volumes
utilize zip file, as their underlying storage format, it is possible to append
an AFF4 volume to the end of any other file type. The WinPmem acquisition tool
utilizes this property to simply package all needed drivers and tools together
with the executable itself - using the AFF4 format.</p>
<p>We typically package with winpmem the 64 bit and 32 bit windows kernel drivers,
as well as a copy of fcat.exe from the sleuthkit . This tool is used to provide
access to the locked pagefiles. (Note that if you just want to extract the
drivers - e.g. to use in another project you can just unzip the winpmem
executable).</p>
<p>If no other operation was specified, WinPmem will immediately image memory and
also acquire certain files, such as drivers and the kernel image. These are
useful to preserve the exact versions of binaries running on the system at the
time of the acquisition.</p>
<p>By default WinPmem uses a technique called PTE Remapping to acquire memory. This
technique was originally developed in order to bypass potential malware hooking
the APIs normally used for acquisition. After much use we found that the
technique is in fact more stable than using the APIs and it is actually the only
reliable way that access to physical memory is achievable on OSX. We therefore
decided to make this the default acquisition mode on both Windows and OSX.</p>
<p>To acquire memory all one needs to do is to specify the output volume:</p>
<div class="highlight"><pre>C:\Users\mic&gt;winpmem_2.0.1.exe -o test.aff4
Driver Unloaded.
CR3: 0x0000187000
 2 memory ranges:
Start 0x00001000 - Length 0x0009E000
Start 0x00100000 - Length 0x3FEF0000
Dumping Range 0 (Starts at 1000)
Dumping Range 1 (Starts at 100000)
Adding C:\Windows\SysNative\drivers/1394bus.sys as file:///C:/Windows/SysNative/drivers/1394bus.sys
Adding C:\Windows\SysNative\drivers/1394ohci.sys as file:///C:/Windows/SysNative/drivers/1394ohci.sys
Adding C:\Windows\SysNative\drivers/acpi.sys as file:///C:/Windows/SysNative/drivers/acpi.sys
Adding C:\Windows\SysNative\drivers/acpipmi.sys as file:///C:/Windows/SysNative/drivers/acpipmi.sys
Adding C:\Windows\SysNative\drivers/adp94xx.sys as file:///C:/Windows/SysNative/drivers/adp94xx.sys
Adding C:\Windows\SysNative\drivers/adpahci.sys as file:///C:/Windows/SysNative/drivers/adpahci.sys
....
Adding C:\Windows\SysNative\drivers/WUDFPf.sys as file:///C:/Windows/SysNative/drivers/WUDFPf.sys
Adding C:\Windows\SysNative\drivers/WUDFRd.sys as file:///C:/Windows/SysNative/drivers/WUDFRd.sys
Driver Unloaded.
</pre></div>


<p>Note that by default the imager also captures the kernel and driver
binaries. You can also choose the snappy compression (<code>--compression snappy</code>)
for a faster compression algorithm.</p>
<p>Now we can use rekall to analyze this image:</p>
<div class="highlight"><pre>C:\Users\mic&gt;&quot;c:\Program Files\Rekall\rekal.exe&quot; -f test.aff4

----------------------------------------------------------------------------
The Rekall Memory Forensic framework 1.3.2 (Dammastock).

&quot;We can remember it for you wholesale!&quot;

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License.

See http://www.rekall-forensic.com/docs/Manual/tutorial.html to get started.
----------------------------------------------------------------------------
[1] test.aff4 15:56:05&gt; pslist
  _EPROCESS            Name          PID   PPID   Thds    Hnds    Sess  Wow64           Start
-------------- -------------------- ----- ------ ------ -------- ------ ------ ------------------------
0xfa8000c9f040 System                   4      0     79      528      - False  2015-04-24 12:12:36+0000
0xfa8000ea3340 SearchProtocol         208   2336      7      284      0 False  2015-04-24 13:37:11+0000
0xfa8001d229f0 smss.exe               228      4      2       29      - False  2015-04-24 12:12:36+0000
</pre></div>


<h1>The LinPmem acquisition tool.</h1>
<p>By default, the linpmem acquisition tool uses the <code>/proc/kcore</code> device to
acquire physical memory. This device must be enabled during kernel configuration
but we found that in most distributions the device is already enabled.</p>
<h1>The OSXPmem acquisition tool</h1>
<p>OSXPmem has recently been updated with a new driver written by Adam Sindelar
called <code>MacPmem.kext</code>. The new driver is more stable and works on all versions
of OSX including the most recent 10.10 series. The new driver presents two
devices:</p>
<ol>
<li>
<p>The <code>/dev/pmem</code> device is the raw physical memory device - reading from this
   device allows userspace applications (running as root) to read physical
   memory - e.g. Rekall itself can be used for live analysis.</p>
</li>
<li>
<p>The <code>/dev/pmem_info</code> device presents information collected by the driver
   about the system - such as the EFI ranges, kernel slide and other critical
   parameters.</p>
</li>
</ol>
<p>The following example illustrates how we can image memory on OSX. First we must
elevate to the root user, then unzip the contents of the <code>osxpmem.zip</code>
distribution. Note that the <code>MacPmem.kext</code> directory and its content must be
owned by root with group wheel, otherwise <code>kextload</code> will refuse to insert the
kernel module.</p>
<p>Next we simply load the driver using <code>kextload</code> and run the acquisition tool to
create the AFF4 volume.</p>
<div class="highlight"><pre><span class="nv">$ </span>sudo bash
Password:
<span class="c"># unzip osxpmem_2.0.1.zip</span>
Archive:  osxpmem_2.0.1.zip
   creating: osxpmem.app/
   creating: osxpmem.app/libs/
  inflating: osxpmem.app/libs/libaff4.0.dylib
  inflating: osxpmem.app/libs/libcrypto.1.0.0.dylib
  inflating: osxpmem.app/libs/libcurl.4.dylib
  inflating: osxpmem.app/libs/libgflags.2.dylib
  inflating: osxpmem.app/libs/libglog.0.dylib
  inflating: osxpmem.app/libs/libiconv.2.dylib
  inflating: osxpmem.app/libs/libidn.11.dylib
  inflating: osxpmem.app/libs/libintl.8.dylib
  inflating: osxpmem.app/libs/liblzma.5.dylib
  inflating: osxpmem.app/libs/libpcre++.0.dylib
  inflating: osxpmem.app/libs/libpcre.1.dylib
  inflating: osxpmem.app/libs/libraptor2.0.dylib
  inflating: osxpmem.app/libs/libsnappy.1.dylib
  inflating: osxpmem.app/libs/libssl.1.0.0.dylib
  inflating: osxpmem.app/libs/liburiparser.1.dylib
  inflating: osxpmem.app/libs/libuuid.16.dylib
  inflating: osxpmem.app/libs/libxml2.2.dylib
  inflating: osxpmem.app/libs/libxslt.1.dylib
  inflating: osxpmem.app/libs/libz.1.dylib
   creating: osxpmem.app/MacPmem.kext/
   creating: osxpmem.app/MacPmem.kext/Contents/
   creating: osxpmem.app/MacPmem.kext/Contents/_CodeSignature/
  inflating: osxpmem.app/MacPmem.kext/Contents/_CodeSignature/CodeResources
  inflating: osxpmem.app/MacPmem.kext/Contents/Info.plist
   creating: osxpmem.app/MacPmem.kext/Contents/MacOS/
  inflating: osxpmem.app/MacPmem.kext/Contents/MacOS/MacPmem
  inflating: osxpmem.app/osxpmem
  inflating: osxpmem.app/README.md
<span class="c"># kextload osxpmem.app/MacPmem.kext/</span>
<span class="c"># ./osxpmem.app/osxpmem -o /tmp/test.aff4</span>
Imaging memory
E0424 16:26:04.297508 <span class="m">2091074320</span> osxpmem.cc:138<span class="o">]</span> Range <span class="m">0</span> 581632
E0424 16:26:04.297526 <span class="m">2091074320</span> osxpmem.cc:138<span class="o">]</span> Range <span class="m">589824</span> 65536
E0424 16:26:04.297534 <span class="m">2091074320</span> osxpmem.cc:138<span class="o">]</span> Range <span class="m">1048576</span> 535822336
E0424 16:26:04.297541 <span class="m">2091074320</span> osxpmem.cc:138<span class="o">]</span> Range <span class="m">538968064</span> 534790144
E0424 16:26:04.297549 <span class="m">2091074320</span> osxpmem.cc:138<span class="o">]</span> Range <span class="m">1073762304</span> 1257820160
E0424 16:26:04.297555 <span class="m">2091074320</span> osxpmem.cc:138<span class="o">]</span> Range <span class="m">2332028928</span> 4096
E0424 16:26:04.297562 <span class="m">2091074320</span> osxpmem.cc:138<span class="o">]</span> Range <span class="m">4294967296</span> 14753464320
 Reading 0x19100000  400MiB / 511MiB 55MiB/s
Adding /mach_kernel as file:///mach_kernel77MiB/s
Adding /dev/pmem_info as file:///dev/pmem_info
Adding /System/Library/Extensions/ALF.kext/Contents/MacOS/ALF as file:///System/Library/Extensions/ALF.kext/Contents/MacOS/ALF
Adding /System/Library/Extensions/ALF.kext/Contents/Resources/Dutch.lproj/ as file:///System/Library/Extensions/ALF.kext/Contents/
Resources/Dutch.lproj/
Adding /System/Library/Extensions/ALF.kext/Contents/Resources/English.lproj/ as file:///System/Library/Extensions/ALF.kext/Content
s/Resources/English.lproj/
...
<span class="c"># cat /dev/pmem_info | head</span>
%YAML 1.2
---
meta:
  pmem_api_version: 1
  cr3: 14860288073
  dtb_off: 14860288000
  phys_mem_size: 17179869184
  pci_config_space_base: 3758096384
  mmap_poffset: 107778048
  mmap_desc_version: 1
  mmap_size: 13776
  mmap_desc_size: 48
  kaslr_slide: 62914560
  kernel_poffset: 63963136
  kernel_version: <span class="s2">&quot;Darwin Kernel Version 13.4.0: Wed Mar 18 16:20:14 PDT 2015; root:xnu-2422.115.14~1/RELEASE_X86_64&quot;</span>
records:
  - purpose: <span class="s2">&quot;(PCI) IGPU/0&quot;</span>
    <span class="nb">type</span>: <span class="s2">&quot;pci_range&quot;</span>
    pci_type: <span class="s2">&quot;PCIUnknownMemory&quot;</span>
    start: 4768923648
    length: 4194304
    hw_informant: <span class="nb">false</span>
</pre></div>


<p>As usual live analysis can be performed by simply specifying the <code>/dev/pmem</code>
device for Rekall.</p>

<p>


  </div>
</div>
</div>
  <div class="footer">
    <div class="container">
      <p class="text-muted">
        &copy; 2015 Google Inc.
        Rekall is licensed under the The GPL License.
        Pmem is licensed under the Apache license.
        <a href="#" class="pull-right text-muted">Back to top</a>
      </p>
    </div>
  </div>

  <script>
   $(".activate_tooltip").tooltip();
   $("body").scrollspy({
     target: ".bs-docs-sidebar",
     offset: 40
   });
  </script>
  </div>
 </body>
</html>

